{"task_id": "HumanEval/156", "completion": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    roman_numerals = {\n        1000: 'm',\n        900: 'cm',\n        500: 'd',\n        400: 'cd',\n        100: 'c',\n        90: 'xc',\n        50: 'l',\n        40: 'xl',\n        10: 'x',\n        9: 'ix',\n        5: 'v',\n        4: 'iv',\n        1: 'i'\n    }\n\n    result = ''\n\n    for key in roman_numerals:\n        while number >= key:\n            result += roman_numerals[key]\n            number -= key\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_int_to_mini_roman.py\nimport unittest\nfrom int_to_mini_roman import int_to_mini_roman\n\n\nclass TestIntToMiniRoman(unittest.TestCase):\n\n    def test_int_to_mini_roman(self):\n        self.assertEqual(int_to_mini_roman(19), 'xix')\n        self.assertEqual(int_to_mini_roman(152), 'clii')\n        self.assertEqual(int_to_mini_roman(426), 'cdxxvi')\n\n\nif __name__ == \"__main__\":\n    unittest.main()", "result": "failed: No module named 'int_to_mini_roman'", "passed": false}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n    return result\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '1' and b[i] == '1':\n            result += '1'\n        else:\n            result += '0'\n    return result\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '1' or b[i] == '1':\n            result += '1'\n        else:\n            result += '0'\n    return result\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n   ", "result": "failed: unterminated triple-quoted string literal (detected at line 74) (<string>, line 56)", "passed": false}
{"task_id": "HumanEval/127", "completion": "\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n    # find intersection\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n\n    # if intervals don't intersect\n    if start > end:\n        return \"NO\"\n\n    # calculate length of intersection\n    length = end - start\n\n    # check if length is prime\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\"\n\n\nprint(intersection((1, 2), (2, 3)))  # \"NO\"\nprint(intersection((-1, 1), (0, 4)))  # \"NO\"\nprint(intersection((-3, -1), (-5, 5)))  # \"YES\"\nprint(intersection((1, 3),", "result": "failed: '(' was never closed (<string>, line 66)", "passed": false}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    strings = ['abc', 'bacd', 'cde', 'array']\n    substring = 'a'\n    print(filter_by_substring(strings, substring))from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    strings = ['abc', 'bacd', 'cde', 'array']\n    substring = 'a'\n    print(filter_by_substring(strings, substring))from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']", "result": "failed: unterminated triple-quoted string literal (detected at line 66) (<string>, line 47)", "passed": false}
{"task_id": "HumanEval/145", "completion": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def sum_of_digits(n):\n        return sum(int(i) for i in str(abs(n)))\n\n    return sorted(nums, key=lambda n: (sum_of_digits(n), nums.index(n)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_order_by_points.py\nimport unittest\nfrom order_by_points import order_by_points\n\n\nclass TestOrderByPoints(unittest.TestCase):\n\n    def test_order_by_points(self):\n        self.assertEqual(order_by_points([1, 11, -1, -11, -12]), [-1, -11, 1, -12, 11])\n        self.assertEqual(order_by_points([]), [])\n        self.assertEqual(order.order_by_points([15, 21, 11, 7]), [7, 15, 21, 11])\n\n\nif __name__ == \"__main__\":\n    unittest.main()#src/config.py\nimport os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n", "result": "failed: No module named 'order_by_points'", "passed": false}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split():\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    test_cases = ['(()())', '((()))', '()', '((())()())']\n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        print(f\"Result: {parse_nested_parens(test_case)}\")\n        print(\"---\")from typing import List\n\ndef find_duplicates(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others appear once.\n    Find all elements that appear twice in this array.\n    Could you do it without extra space and in O(n) runtime?\n\n    >>> find_duplicates([4,3,2,7,8,2,3,1])\n    [2, 3]\n    \"\"\"\n    duplicates = []\n    for num in nums:\n        if nums[abs", "result": "failed: invalid syntax (<string>, line 46)", "passed": false}
{"task_id": "HumanEval/63", "completion": "\n\ndef fibfib(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(n - ):\n            a, b, c = b, c, a + b + c\n        return c\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n#tests/test_fibfib.py\nimport pytest\nfrom fibfib import fibfib\n\n\n@pytest.mark.parametrize(\"n, expected\", [\n    (0, 0),\n    (1, 0),\n    (2, 1),\n    (3, 1),\n    (4, 2),\n    (5, 4),\n    (6, 8),\n    (7, 16),\n    (8, 24),\n    (9, 40),\n    (10, 68),\n])\ndef test_fibfib(n, expected):\n    assert fibfib(n) == expected#src/config.py\nimport os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE", "result": "failed: invalid syntax (<string>, line 41)", "passed": false}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    music_list = music_string.split()\n    beats_list = []\n    for note in music_list:\n        if note == 'o':\n            beats_list.append(4)\n        elif note == 'o|':\n            beats_list.append(2)\n        elif note == '.|':\n            beats_list.append(1)\n    return beats_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    music_string = 'o o| .| o| o| .| .| .| .| o o'\n    print(parse_music(music_string))  # [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\n# vim: set et ts=4 sw=4 sts=4:from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note", "result": "failed: unterminated triple-quoted string literal (detected at line 76) (<string>, line 55)", "passed": false}
{"task_id": "HumanEval/61", "completion": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack or stack.pop() != \"(\":\n                return False\n    return not stack\n\n\ndef test_correct_bracketing():\n    assert correct_bracketing(\"(\") == False\n    assert correct_bracketing(\"()\") == True\n    assert correct_bracketing(\"(()())\") == True\n    assert correct_bracketing(\")(()\") == False\n\n\ntest_correct_bracketing()\n\n# \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uba74 \ubb38\uc81c\ub97c \ud6a8\uc728\uc801\uc73c\ub85c \ud574\uacb0\ud560 \uc218 \uc788\ub2e4. \uc2a4\ud0dd\uc740 \ub9c8\uc9c0\ub9c9\uc5d0 \ub4e4\uc5b4\uc628 \uc6d0\uc18c\uac00 \uba3c\uc800 \ub098\uac00\ub294 \uad6c\uc870\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc11c \uc774 \ubb38\uc81c\uc5d0 \uc801\ud569\ud558\ub2e4. \uc2a4\ud0dd\uc5d0 \uc6d0\uc18c\ub97c \ub123\uc73c\uba74\uc11c \uc5ec\ub294 \uad04\ud638\ub97c \ub9cc\ub098\uba74 \ufffd", "result": "passed", "passed": true}
{"task_id": "HumanEval/66", "completion": "\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n\n\nprint(digitSum(\"abAB\"))  # 131\nprint(digitSum(\"abcCd\"))  # 67\nprint(digitSum(\"helloE\"))  # 69\nprint(digitSum(\"woArBld\"))  # 131\nprint(digitSum(\"aAaaaXa\"))  # 153\nprint(digitSum(\"\"))  # 0\n\n# 131 is the sum of ASCII values of A (65) and B (66)\n# 67 is the sum of ASCII values of a (97), b (98) and C (67)\n# 69 is the sum of ASCII values of h (104), e (101) and E (69)\n# 131 is the sum of ASCII values of w (119), o (111), A (65) and B (66)\n# 153 is the sum of ASCII values of a (97), A (65), a (97), a (97) and X (88)\n# 0 is the sum of no uppercase characters.\n\n# ord() function returns an integer representing the Unicode character.\n# isupper() method returns True if the string is an uppercase letter.\n# sum() function returns the sum of all items in an iterable.\n# The iterable items are the ASCII values of the uppercase characters in the string.\n# The sum is the sum of the ASCII values of the uppercase characters in", "result": "passed", "passed": true}
{"task_id": "HumanEval/104", "completion": "\ndef unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    def has_even_digit(n):\n        return any(int(digit) % 2 == 0 for digit in str(n))\n\n    return sorted([n for n in x if not has_even_digit(n)])\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_unique_digits.py\nimport unittest\nfrom unique_digits import unique_digits\n\nclass TestUniqueDigits(unittest.TestCase):\n\n    def test_unique_digits(self):\n        self.assertEqual(unique_digits([15, 33, 1422, 1]), [1, 15, 33])\n        self.assertEqual(unique_digits([152, 323, 1422, 10]), [])\n        self.assertEqual(unique_digits([123, 456, 789, 100]), [123, 456, 789])\n        self.assertEqual(unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\nif __name__ == '__main__':\n    unittest.main()import unittest\nfrom unique_digits import unique", "result": "failed: invalid syntax (<string>, line 50)", "passed": false}
{"task_id": "HumanEval/137", "completion": "\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    if a == b:\n        return None\n    if isinstance(a, str):\n        a = float(a.replace(\",\", \".\"))\n    if isinstance(b, str):\n        b = float(b.replace(\",\", \".\"))\n    if isinstance(a, float):\n        a = a.as_integer_ratio()[0]\n    if isinstance(b, float):\n        b = b.as_integer_ratio()[0]\n    return max(a, b)\n\n\nprint(compare_one(1, 2.5))  # \u279e 2.5\nprint(compare_one(1, \"2,3\"))  # \u279e \"2,3\"\nprint(compare_one(\"5,1\", \"6\"))  # \u279e \"6\"\nprint(compare(1, 1))  # \u279e None\n\n\ndef compare_two(a, b):\n    \"\"\"\n    Create a function that takes two integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_two(1, 2.5) \u279e 2.5\n    compare_two(1, \"2,3\") \u279e \"2,3\"\n    compare_two", "result": "failed: unterminated triple-quoted string literal (detected at line 72) (<string>, line 47)", "passed": false}
{"task_id": "HumanEval/116", "completion": "\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()# https://www.codewars.com/kata/525f3eda17c7cd9f9e000b39\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_square(n):\n    if n < 0:\n        return False\n    return n**0.5 == int(n**0.5)\n\n\ndef is_cube(n):\n    if n < 0:\n        return False\n    return n**(1./3.) == int(n**(1./3.))\n\n\ndef is_fourth_power(n):\n    if n < 0:\n        return False\n    return n**0.25 == int(n**0.25)\n\n\ndef is_fifth_power(n):\n    if n < 0:\n        return False\n    return n**0.2 == int(n**0.2)\n\n\ndef", "result": "failed: invalid syntax (<string>, line 65)", "passed": false}
{"task_id": "HumanEval/0", "completion": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n# 1.0, 2.0, 3.0 -> False\n# 1.0, 2.8, 3.0, 4.0, 5.0, 2.0 -> True\n# 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 -> False\n# 1.0, 2.8, 3.0, 4.0, 5.0, 2.0 -> True\n# 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 -> False\n# 1.0, 2.8, 3.0, 4.0, 5.0, 2.0 -> True\n# 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 -> False\n# 1.0, 2.8, 3.0, 4.0, 5.0, 2.0 -> True\n# 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 ->", "result": "passed", "passed": true}
{"task_id": "HumanEval/48", "completion": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]\n\n\ndef is_prime(n: int):\n    \"\"\"\n    Checks if given number is a prime\n    >>> is_prime(2)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(13)\n    True\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** rt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_even(n: int):\n    \"\"\"\n    Checks if given number is even\n    >>> is_even(0)\n    True\n    >>> is_even(3)\n    False\n    >>> is_even(4)\n    True\n    \"\"\"\n    return n % 2 == 0\n\n\ndef is_odd(n: int):\n    \"\"\"\n    Checks if given number is odd\n    >>> is_odd(1)\n    True\n    >>> is_odd(2)\n    False\n    >>> is_odd(3)\n    True\n    \"\"\"\n    return n % 2 != 0\n\n\ndef is_leap_year(year: int):\n    \"\"\"\n    Checks if given year is a leap year\n    >>> is_leap_year(2000)\n    True\n    >>> is_leap_year(1900)\n    False\n    >>> is_leap_year(2004)\n    True\n    \"\"\"\n    if year % 4 != 0:\n        return False\n    elif year % 100 != 0:\n        return True\n    elif year % 40", "result": "failed: expected ':' (<string>, line 92)", "passed": false}
{"task_id": "HumanEval/86", "completion": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    new_words = []\n    for word in words:\n        new_word = ''.join(sorted(word))\n        new_words.append(new_word)\n    return ' '.join(new_words)\n\n\nprint(anti_shuffle('Hello World!!!'))\nprint(anti_shuffle('Hi'))\nprint(anti_shuffle('hello'))\nprint(anti_shuffle('a quick brown fox jumps over the lazy dog'))\nprint(anti_shuffle('A Sorted String'))\nprint(anti_shuffle('1234567890'))\nprint(anti_shuffle('The quick brown fox jumps over the lazy dog'))\nprint(anti_shuffle(''))\nprint(anti_shuffle(' '))\nprint(anti_shuffle('!'))\nprint(anti_shuffle('123 456 789 0'))\nprint(anti_shuffle('A Sorted String'))\nprint(anti_shuffle('1234567890'))\nprint(anti_shuffle('The quick brown fox jumps over the lazy dog'))\nprint(anti_shuffle(''))\nprint(anti_shuffle(' '))\nprint(anti_shuffle('!'))\nprint(anti))\nprint(anti_shuffle('123 456 789 0'))\nprint(anti_shuffle('A Sorted String'))\nprint(anti_shuffle('", "result": "failed: unmatched ')' (<string>, line 54)", "passed": false}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#test_closest_elements.py\nimport unittest\nfrom closest_elements import find_closest_elements\n\nclass TestClosestElements(unittest.TestCase):\n\n    def test_find_closest_elements(self):\n        self.assertEqual(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2))\n        self.assertEqual(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0))\n        self.assertEqual(find_closest_elements([1.0, 2.0, 3.0", "result": "failed: '[' was never closed (<string>, line 47)", "passed": false}
{"task_id": "HumanEval/83", "completion": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    return 2 * 9 * 10**(n-2)\n\n\ndef starts_ends_both(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start and end with the same digit.\n    \"\"\"\n    return 9 * 10**(n-2)\n\n\ndef starts_ends_neither(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that neither start nor end with 1.\n    \"\"\"\n    return 8**n - 2 * 9 * 10**(n-2)\n\n\ndef main():\n    n = int(input(\"Enter the number of digits: \"))\n    print(\"Count of numbers that start or end with 1: \", starts_one_ends(n))\n    print(\"Count of numbers that start and end with the same digit: \", starts_ends_both(n))\n    print(\"Count of numbers that neither start nor end with 1: \", starts_ends_neither(n))\n\n\nif __name__ == \"__main__\":\n    main()\n\n#test_count_numbers.py\nimport unittest\nfrom count_numbers import starts_one_ends, starts_ends_both, starts_ends_neither\n\n\nclass TestCountNumbers(unittest.TestCase):\n\n    def test_starts_one_ends(self):\n        self.assertEqual(starts_one_ends(2), 18)\n        self.assertEqual(starts_one_ends(3), 180)\n        self.assertEqual(starts_one_ends(4), 1800)\n\n    def test_starts_ends_both(self):\n        self.assertEqual(starts_ends_both(2), 9)\n        self.assertEqual(starts_ends_both(3), ", "result": "failed: '(' was never closed (<string>, line 56)", "passed": false}
{"task_id": "HumanEval/2", "completion": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number % 1\n\n\ndef main():\n    \"\"\"\n    Main function to test the other functions.\n    \"\"\"\n    print(f\"The number 3.5 has a decimal part of {truncate_number(3.5)}\")\n    print(f\"The number 4.7 has a decimal part of {truncate_number(4.7)}\")\n    print(f\"The number 10.99 has a decimal part of {truncate(10.99)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n#tests/test_truncate_number.py\nimport pytest\nfrom truncate_number import truncate_number\n\n\ndef test_truncate_number():\n    assert truncate_number(3.5) == 0.5\n    assert truncate_number(4.7) == 0.7\n    assert truncate_number(10.99) == 0.99\n    assert truncate_number(0) == 0\n    assert truncate_number(-3.5) == 0.5\n    assert truncate_number(-4.7) == 0.7\n    assert truncate_number(-10.99) == 0.99\n    assert truncate_number(float('inf')) == 0\n    assert truncate_number(float('-inf')) == 0\n    assert truncate_number(float('nan')) == float('nan')\n\n#tests/test_truncate_number_2.py\nimport pytest\nfrom truncate_number import truncate_number\n\n\ndef test_truncate_number():\n    assert truncate_number(3.5) == 0.5\n    assert truncate_number(4", "result": "failed: '(' was never closed (<string>, line 62)", "passed": false}
{"task_id": "HumanEval/41", "completion": "\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n * n\n\n\ndef main():\n    print(car_race_collision(3))\n\n\nif __name__ == \"__main__\":\n    main()\n\n#tests/test_car_race_collision.py\nimport pytest\nfrom car_race_collision import car_race_collision\n\n\ndef test_car_race_collision():\n    assert car_race_collision(1) == 1\n    assert car_race_collision(2) == 4\n    assert car_race_collision(3) == 9\n    assert car_race_collision(4) == 16\n    assert car_race_collision(5) == 25\n    assert car_race_collision(10) == 100\n    assert car_race_collision(20) == 400\n    assert car_race_collision(100) == 10000\n\n#tests/test_main.py\nfrom car_race_collision import main\n\n\ndef test_main():\n    assert main() is None  # main function should not return anything.\n\n#tests/test_solution.py\nimport pytest\nfrom car_race_collision import car_race_collision\n\n\ndef test_solution():\n    assert car_race_collision(1) == 1\n   ", "result": "failed: No module named 'car_race_collision'", "passed": false}
