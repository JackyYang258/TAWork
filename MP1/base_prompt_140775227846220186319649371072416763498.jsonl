{"task_id": "HumanEval/156", "completion": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    # TODO: Implement this function\n    pass\n\n\ndef mini_roman_to_int(roman):\n    \"\"\"\n    Given a string representing a roman numeral, return its integer equivalent.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> mini_roman_to_int('xix') == 19\n    >>> mini_roman_to_int('clii') == 152\n    >>> mini_roman_to_int('cdxxvi') == 426\n    \"\"\"\n    # TODO: Implement this function\n    pass\n\n\ndef roman_to_int(roman):\n    \"\"\"\n    Given a string representing a roman numeral, return its integer equivalent.\n    Restrictions: 1 <= num <= 3999\n\n    Examples:\n    >>> roman_to_int('xix') == 19\n    >>> roman_to_int('clii') == 152\n    >>> roman_to_int('cdxxvi') == 426\n    >>> roman_to_int('mmmcmxcix') == 3999\n    \"\"\"\n    # TODO: Implement this function\n    pass\n\n\ndef int_to_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 3999\n\n    Examples:\n    >>> int_to_roman(19) == 'xix'\n    >>> int_to_roman(152"}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list(a: str, b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list('010', ['110', '101', '011'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_list(['010', '110'], ['110', '101', '011'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list_list_list(a: List[str], b: List[str], c: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_list_list(['010', '11"}
{"task_id": "HumanEval/127", "completion": "\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n    # your code here\n    if interval1[1] < interval2[0] or interval2[1] < interval1[0]:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n\n\ndef filter_by_substring_2(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_by_substring_2([], 'a')\n    []\n    >>> filter_by_substring_2(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda s: substring in s, strings))\n\n\ndef filter_by_substring_3(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring_3([], 'a')\n    []\n    >>> filter_by_substring_3(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list(filter(lambda s: substring in s, strings))\n\n\ndef filter_by_substring_4(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring_4([], 'a')\n    []\n    >>> filter_by_substring_4(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return list("}
{"task_id": "HumanEval/145", "completion": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    return sorted(nums, key=lambda x: (sum(map(int, str(abs(x)))), x))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split():\n        stack = []\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                stack.append(char)\n                max_depth = max(max_depth, len(stack))\n            elif char == ')':\n                stack.pop()\n        result.append(max_depth)\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/63", "completion": "\n\ndef fibfib(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\n\ndef fibfib_memo(n: int, memo: dict):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0:\n        return 0"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    music_string = music_string.split()\n    music_list = []\n    for i in music_string:\n        if i == 'o':\n            music_list.append(4)\n        elif i == 'o|':\n            music_list.append(2)\n        elif i == '.|':\n            music_list.append(1)\n    return music_list\n\n\ndef parse_music_2(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music_2('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    music_string = music_string.split()\n    music_list = []\n    for i in music_string:"}
{"task_id": "HumanEval/61", "completion": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    if brackets == \"\":\n        return True\n    if brackets[0] == \"(\" and brackets[-1] == \")\":\n        return correct_bracketing(brackets[1:-1])\n    return False\n\n\ndef is_palindrome(s: str):\n    \"\"\" s is a string.\n    return True if s is a palindrome.\n\n    >>> is_palindrome(\"\")\n    True\n    >>> is_palindrome(\"a\")\n    True\n    >>> is_palindrome(\"ab\")\n    False\n    >>> is_palindrome(\"abba\")\n    True\n    >>> is_palindrome(\"abbba\")\n    False\n    >>> is_palindrome(\"abbaa\")\n    False\n    >>> is_palindrome(\"abbbaa\")\n    False\n    >>> is_palindrome(\"abbbaab\")\n    True\n    >>> is_palindrome(\"abbbaabb\")\n    False\n    >>> is_palindrome(\"abbbaabba\")\n    True\n    >>> is_palindrome(\"abbbaabbba\")\n    True\n    >>> is_palindrome(\"abbbaabbbaa\")\n    False\n    >>> is_palindrome(\"abbbaabbbaab\")\n    True\n    >>> is_palindrome(\"abbbaabbbaabb\")\n    False\n    >>> is_palindrome(\"abbbaabbbaabba\")\n    True\n    >>> is_palindrome(\"abbbaabbbaabbaa\")\n    False\n    >>> is_palindrome(\"abbbaabbbaabbaab\")\n    True\n    >>>"}
{"task_id": "HumanEval/66", "completion": "\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n\n\ndef digitSum2(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n\n\ndef digitSum3(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n\n\ndef digitSum4(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n"}
{"task_id": "HumanEval/104", "completion": "\ndef unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [i for i in x if all(int(j) % 2 != 0 for j in str(i))]\n\n\ndef unique_digits_2(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn' even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [i for i in x if all(int(j) % 2 != 0 for j in str(i))]\n\n\ndef unique_digits_3(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [i for i in x if all(int(j) % 2 != 0 for j in str(i))]\n\n\ndef unique_digits_4(x"}
{"task_id": "HumanEval/137", "completion": "\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None\n    \"\"\"\n    if type(a) == type(b):\n        if a == b:\n            return None\n        elif type(a) == int:\n            if a > b:\n                return a\n            else:\n                return b\n        elif type(a) == float:\n            if a > b:\n                return a\n            else:\n                return b\n        elif type(a) == str:\n            if a > b:\n                return a\n            else:\n                return b\n    else:\n        if type(a) == int:\n            return a\n        elif type(a) == float:\n            return a\n        elif type(a) == str:\n            return a\n        elif type(b) == int:\n            return b\n        elif type(b) == float:\n            return b\n        elif type(b) == str:\n            return b\n\n\ndef compare_one_2(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \""}
{"task_id": "HumanEval/116", "completion": "\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n\n\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n\n\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, "}
{"task_id": "HumanEval/0", "completion": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/48", "completion": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]\n\n\ndef is_palindrome_recursive(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome_recursive('')\n    True\n    >>> is_palindrome_recursive('aba')\n    True\n    >>> is_palindrome_recursive('aaaaa')\n    True\n    >>> is_palindrome_recursive('zbcd')\n    False\n    \"\"\"\n    if len(text) <= 1:\n        return True\n    if text[0] != text[-1]:\n        return False\n    return is_palindrome_recursive(text[1:-1])\n\n\ndef is_palindrome_iterative(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome_iterative('')\n    True\n    >>> is_palindrome_iterative('aba')\n    True\n    >>> is_palindrome_iterative('aaaaa')\n    True\n    >>> is_palindrome_iterative('zbcd')\n    False\n    \"\"\"\n    for i in range(len(text) // 2):\n        if text[i] != text[-i - 1]:\n            return False\n    return True\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/86", "completion": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(sorted(s.split(), key=lambda x: x.lower()))\n\n\ndef anti_shuffle_2(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(sorted(s.split(), key=lambda x: x.lower()))\n\n\ndef anti_shuffle_3(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti('Hello World!!!') returns 'Hello !!!Wdlor'\n   "}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = numbers[1] - numbers[0]\n    min_pair = (numbers[0], numbers[1])\n    for i in range(1, len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (numbers[i], numbers[i + 1])\n    return min_pair\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/83", "completion": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 10\n    else:\n        return 9 * starts_one_ends(n - 1)\n\n\ndef starts_one_ends_ends_one(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1 and have 1 as the second digit.\n    \"\"\"\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return 10 * starts_one_ends_ends_one(n - "}
{"task_id": "HumanEval/2", "completion": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number % 1\n\n\ndef get_decimal_part(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> get_decimal_part(3.5)\n    0.5\n    \"\"\"\n    return number % 1\n\n\ndef get_integer_part(number: float) -> int:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the integer part of the number.\n    >>> get_integer_part(3.5)\n    3\n    \"\"\"\n    return int(number)\n\n\ndef get_sign(number: float) -> int:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the sign of the number.\n    >>> get_sign(3.5)\n    1\n    >>> get_sign(-3.5)\n    -1\n    \"\"\"\n    return 1 if number >= 0 else -1\n\n\ndef get_sign_and_integer_part(number: float) -> tuple[int, int]:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1)."}
{"task_id": "HumanEval/41", "completion": "\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n * (n - 1) // 2\n\n\ndef car_race_collision_probability(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the probability of a collision.\n    \"\"\"\n    return 1 / (n * (n - 1))\n\n\ndef car_race_collision_probability_asymptotic(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However"}
